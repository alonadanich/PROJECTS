1. Для стандартного набору монет [50, 25, 10, 5, 2, 1] для суми 1131313 обидва алгоритми працюють однаково добре (результат жадібного алгоритму: {50: 22626, 10: 1, 2: 1, 1: 1}, результат динамічного програмування: {1: 1, 2: 1, 10: 1, 50: 22626}). Жадібний алгоритм працює швидше, ніж динамічне програмування (час виконання для жадібного алгоритму: 0.000000, час виконання для динамічного програмування: 1.107066). Для невеликої суми 113 час виконання настільки малий, що його неможливо відслідкувати в обох випадках.
2. Для набору монет з нестандартним номіналом [9, 7, 6, 1] для суми 111 жадібний алгоритм дає неоптимальний результат ({9: 12, 1: 3} замість {7: 3, 9: 10}), тобто 15 монет при можливості надати всього 13. Хоча швидкість виконання 0.000000 при тому, що при динамічному програмуванні швидкість 0.000999. 

Отже, можна зробити висновок, що жадібний алгоритм підходить для стандарних наборів монет, де він працює швидко та ефективно. Динамічне програмування працює повільніше для великих значень суми через збільшення кількості обчислень, але гарантує оптимальне рішення. Обидва алгоритми мають свої переваги і їх потрібно обирати залежно від ситуації.
